package lang.temper.builtin

import lang.temper.ast.TreeVisit
import lang.temper.common.putMultiList
import lang.temper.common.soleElementOrNull
import lang.temper.env.InterpMode
import lang.temper.log.FilePath
import lang.temper.log.Position
import lang.temper.log.UNIX_FILE_SEGMENT_SEPARATOR
import lang.temper.name.BuiltinName
import lang.temper.name.ExportedName
import lang.temper.name.LibraryNameLocationKey
import lang.temper.name.ModuleName
import lang.temper.name.ParsedName
import lang.temper.name.ResolvedName
import lang.temper.name.Symbol
import lang.temper.type2.Signature2
import lang.temper.value.BlockTree
import lang.temper.value.BuiltinStatelessMacroValue
import lang.temper.value.CallTree
import lang.temper.value.DeclTree
import lang.temper.value.EscTree
import lang.temper.value.MacroEnvironment
import lang.temper.value.NameLeaf
import lang.temper.value.NamedBuiltinFun
import lang.temper.value.NotYet
import lang.temper.value.PartialResult
import lang.temper.value.Planting
import lang.temper.value.PostPass
import lang.temper.value.TEdge
import lang.temper.value.TString
import lang.temper.value.TSymbol
import lang.temper.value.TreeTemplate
import lang.temper.value.Value
import lang.temper.value.asSymbol
import lang.temper.value.curliesBuiltinName
import lang.temper.value.functionContained
import lang.temper.value.importBuiltinName
import lang.temper.value.importedSymbol
import lang.temper.value.initSymbol
import lang.temper.value.resolutionSymbol
import lang.temper.value.valueContained

/**
 * `importMe(\nameToImport, "std/foo")` may be generated by macros to specify
 * names in other modules or libraries that may need to be imported.
 *
 * *[makeImportMeCall]\(pos, symbol, importSpecifierString, macroEnv\)* builds
 * a call to this and schedules [ImportMePostPass] to replace it with the local
 * name of an appropriate import.
 *
 * For example, given a module body like the BEFORE, we transform it to the AFTER.
 *
 *     // BEFORE
 *     @imported(\(somelib.f)) let f__0 = ...;  // f imported from somelib
 *     @imported(\(somelib.x)) let x__0 = ...;  // x imported from somelib
 *     f(
 *       importMe(\foo, "other-lib/baz"),
 *       importMe(\bar, "other-lib/baz"),
 *       importMe(\x, "somelib")
 *     )
 *
 *     // AFTER
 *     @imported(\(somelib.f)) let f__0 = ...;
 *     @imported(\(somelib.x)) let x__0 = ...;  // reused
 *     let { foo as foo__0, bar as bar__0 } = import("other-lib/baz"); // inserted
 *     f(
 *       foo__0, // Rewritten to names
 *       bar__0,
 *       x__0
 *     )
 */
data object ImportMe : BuiltinStatelessMacroValue, NamedBuiltinFun {
    override val name: String = "importMe"

    override val sigs: List<Signature2>? = null

    override fun invoke(macroEnv: MacroEnvironment, interpMode: InterpMode): PartialResult = NotYet
}

fun Planting.makeImportMeCall(
    pos: Position,
    nameText: Symbol,
    importSpecifier: String,
    macroEnvironment: MacroEnvironment,
): TreeTemplate<CallTree> {
    macroEnvironment.runAfterReplacement(ImportMePostPass)
    return Call(pos, ImportMe) {
        V(nameText)
        V(Value(importSpecifier, TString))
    }
}

data object ImportMePostPass : PostPass {
    override fun rewrite(root: BlockTree) {
        // We're going to gather calls to replace.
        data class ImportMeCall(
            val edge: TEdge,
            val nameText: Symbol,
            val importSpecifier: String,
        )

        // We're going to gather declarations created by importing.
        data class ImportDecl(
            val localName: ResolvedName,
            val nameText: Symbol,
            val importSpecifier: String,
        )

        // We'll need access to library names to canonicalize import specifiers
        val sharedLocationContext = root.document.context.sharedLocationContext

        val importDecls = mutableMapOf<Pair<Symbol, String>, ImportDecl>()
        val importMeCalls = mutableListOf<ImportMeCall>()
        val nameMaker = root.document.nameMaker

        TreeVisit.startingAt(root)
            .forEachContinuing { t ->
                when (t) {
                    is CallTree -> if (t.size == IMPORT_ME_CHILD_COUNT) {
                        val callee = t.child(0)
                        if (callee.functionContained == ImportMe) {
                            val nameText = t.child(1).valueContained(TSymbol)
                            val importSpecifier = t.child(2).valueContained(TString)
                            if (nameText != null && importSpecifier != null) {
                                importMeCalls.add(
                                    ImportMeCall(t.incoming!!, nameText, importSpecifier),
                                )
                            }
                        }
                    }
                    is DeclTree -> t.parts?.let { parts ->
                        val remoteName = parts.metadataSymbolMap[importedSymbol]?.let {
                            val esc = it.target as? EscTree
                            val nameLeaf = esc?.children?.soleElementOrNull as? NameLeaf
                            nameLeaf?.content as? ExportedName
                        }
                        val remoteLoc = remoteName?.origin?.loc
                        if (remoteLoc is ModuleName) {
                            val libraryName =
                                sharedLocationContext[remoteLoc, LibraryNameLocationKey]
                            if (libraryName != null) {
                                val specifier = buildString {
                                    append(libraryName.text)
                                    append(UNIX_FILE_SEGMENT_SEPARATOR)
                                    remoteLoc.appendRelativePathAndSuffix(this)
                                    if (
                                        this.endsWith(UNIX_FILE_SEGMENT_SEPARATOR) &&
                                        remoteLoc.relativePath() != FilePath.emptyPath
                                    ) {
                                        this.setLength(this.length - UNIX_FILE_SEGMENT_SEPARATOR.length)
                                    }
                                }
                                var localName = parts.name.content
                                if (localName is ParsedName) {
                                    // If we don't know the local name for an import as a ResolvedName,
                                    // pre-allocate a SourceName as necessary and store it for the
                                    // name resolution pass to use.
                                    localName = (parts.metadataSymbolMap[resolutionSymbol]?.target as NameLeaf?)
                                        ?.content as ResolvedName?
                                        ?: nameMaker.unusedSourceName(localName).also { resolution ->
                                            t.insert {
                                                V(t.pos.rightEdge, resolutionSymbol)
                                                Ln(t.pos.rightEdge, resolution)
                                            }
                                        }
                                }
                                check(localName is ResolvedName)
                                val d = ImportDecl(
                                    localName, remoteName.baseName.toSymbol(), specifier,
                                )
                                importDecls[d.nameText to d.importSpecifier] = d
                            }
                        }
                    }
                    else -> Unit
                }
            }
            .visitPreOrder()
        // Now we've found everything we need to work on

        // We might need to add some import statements to populate the scope.
        //     let { nameText as resolvedName } = import(importSpecifier);
        val importsNeeded = mutableMapOf<String, MutableList<Pair<Symbol, ResolvedName>>>()

        // Go through the calls to ImportMe that we found above and replace them with NameLeaves.
        for (importMeCall in importMeCalls) {
            val importSpecifier = importMeCall.importSpecifier
            val nameText = importMeCall.nameText
            val importDecl = importDecls.getOrPut(nameText to importSpecifier) {
                val newName = nameMaker.unusedSourceName(ParsedName(nameText.text))
                importsNeeded.putMultiList(
                    importSpecifier,
                    nameText to newName,
                )
                ImportDecl(newName, nameText, importSpecifier)
            }
            importMeCall.edge.replace { pos ->
                Rn(pos, importDecl.localName)
            }
        }

        if (importsNeeded.isNotEmpty()) {
            val start = root.pos.leftEdge
            root.insert(at = 0) {
                for ((importSpecifier, needed) in importsNeeded) {
                    Decl(pos = start) {
                        Call {
                            Rn(curliesBuiltinName)
                            for ((nameText, localName) in needed) {
                                Ln(BuiltinName(nameText.text))
                                V(asSymbol)
                                Ln(localName)
                            }
                        }
                        V(initSymbol)
                        Call {
                            Rn(importBuiltinName)
                            V(Value(importSpecifier, TString))
                        }
                    }
                }
            }
        }
    }
}

private const val IMPORT_ME_CHILD_COUNT = 3 // callee, name, import-specifier
