package lang.temper.be

import lang.temper.be.FunctionalTestDiagnosticPreferences.Companion.mightDoSomething
import lang.temper.be.cli.Aux
import lang.temper.be.cli.CliFailure
import lang.temper.be.cli.EffortSuccess
import lang.temper.be.cli.RunLibraryRequest
import lang.temper.be.cli.RunTestsRequest
import lang.temper.be.cli.ToolchainRequest
import lang.temper.be.cli.effort
import lang.temper.be.syncstaging.applyBackendsSynchronously
import lang.temper.be.tmpl.TmpL
import lang.temper.common.ContentHash
import lang.temper.common.ListBackedLogSink
import lang.temper.common.Log
import lang.temper.common.RFailure
import lang.temper.common.RResult
import lang.temper.common.RSuccess
import lang.temper.common.TestWebServer
import lang.temper.common.TextOutput
import lang.temper.common.console
import lang.temper.common.currents.CancelGroup
import lang.temper.common.currents.makeCancelGroupForTest
import lang.temper.common.isNotEmpty
import lang.temper.common.json.JsonValue
import lang.temper.format.TextOutputTokenSink
import lang.temper.frontend.Module
import lang.temper.fs.MemoryFileSystem
import lang.temper.fs.OutDir
import lang.temper.fs.OutputRoot
import lang.temper.fs.temperKeepSegment
import lang.temper.lexer.isTemperFile
import lang.temper.lexer.languageConfigForExtension
import lang.temper.library.DependencyResolver
import lang.temper.library.LibraryConfiguration
import lang.temper.library.LibraryConfigurationsBundle
import lang.temper.log.CompilationPhase
import lang.temper.log.FilePath
import lang.temper.log.FilePositions
import lang.temper.log.LogSink
import lang.temper.log.MessageTemplate
import lang.temper.log.dirPath
import lang.temper.name.BackendId
import lang.temper.name.DashedIdentifier
import lang.temper.name.ImplicitsCodeLocation
import lang.temper.name.ModuleLocation
import lang.temper.name.ModuleName
import lang.temper.tests.FunctionalTestBase
import lang.temper.tests.FunctionalTestSuiteI
import lang.temper.tests.PreparedFunctionalTest
import lang.temper.tests.assertTestingTestFromJunit
import lang.temper.tests.checkStaticErrors
import lang.temper.tests.prepareModulesForFunctionalTest
import lang.temper.value.PseudoCodeDetail
import lang.temper.value.TemperFormattingHints
import lang.temper.value.toPseudoCode
import org.junit.jupiter.api.AfterAll
import org.junit.jupiter.api.BeforeAll
import kotlin.collections.get
import kotlin.test.AfterTest
import kotlin.test.BeforeTest
import kotlin.test.fail
import lang.temper.supportedBackends.lookupFactory as defaultLookupFactory

private val BackendId.needsHackyBundlingHack: Boolean // HACK
    get() {
        val uniqueId = this.uniqueId
        if (uniqueId.startsWith("java")) {
            // Our Java backend uses Maven to build and run code.
            // Maven requires each project to be built and installed
            // semi-globally instead unless you do a Maven multi-module
            // build: www.baeldung.com/maven-multi-module
            // You can use a parent POM to tie together a bunch of modules
            // so that you do not have to separately build and install them,
            // but for that to work, you need to modify each submodule's
            // metadata file in a way that you would not want when publishing.
            //
            // > in the individual submodulesâ€™ pom.xml, it will add the
            // > parent-project in the parent section
            //
            // Long term, we will probably want to jump through those hoops
            // to install into a scoped maven repository, possibly with
            // non-publication POM metadata, but in the short term, we just
            // jam everything into one source tree.
            val rest = uniqueId.substring("java".length)
            return rest.all { it in '0'..'9' }
        }
        return false
    }

/**
 * Supports running the functional test suite on code generated by a backend.
 */
abstract class FunctionalTestRunner<BACKEND : Backend<BACKEND>>(
    val factory: Backend.Factory<BACKEND>,
    otherFactories: Set<Backend.Factory<*>> = setOf(),
) : FunctionalTestSuiteI {
    override val cancelGroup: CancelGroup get() = _cancelGroup!!
    private var _cancelGroup: CancelGroup? = null

    @BeforeTest
    fun makeCancelGroup() {
        _cancelGroup = makeCancelGroupForTest()
    }

    @AfterTest
    fun tearDownCancelGroup() {
        _cancelGroup = null
    }

    override val backendId: BackendId
        get() = factory.backendId

    open fun getDiagnosticPreferences(test: FunctionalTestBase): FunctionalTestDiagnosticPreferences =
        FunctionalTestDiagnosticPreferences.defaultPreferences

    private val otherFactoryMap = otherFactories.associate { it.backendId to it }
    open fun lookupFactory(backendId: BackendId): Backend.Factory<*>? = when (backendId) {
        // In case the factory is already specialized, use the given factory for the given id.
        factory.backendId -> factory
        else -> otherFactoryMap[backendId] ?: defaultLookupFactory(backendId)
    }

    override fun runFunctionalTest(
        test: FunctionalTestBase,
        verbose: Boolean,
    ) {
        val backendId = factory.backendId
        val diagnosticPreferences = getDiagnosticPreferences(test)

        val backendOrganization = organizeBackends(
            listOf(backendId),
            lookupFactory = ::lookupFactory,
            onMissingFactory = { error(it) },
        )
        // TODO Actually build by buckets?
        val outputRoot = OutputRoot(MemoryFileSystem())
        val inputs = test.temperFiles.toList()
        val logSink = ListBackedLogSink()

        val preparedModules = prepareModulesForFunctionalTest(
            test,
            projectLogSink = logSink,
            customizeModule = { module, _ ->
                module.addEnvironmentBindings(server.makeBindings())
                for (factory in backendOrganization.factoriesById.values) {
                    module.addEnvironmentBindings(factory.environmentBindings)
                }
            },
        )

        // TODO Build by buckets?
        val neededBackendIds = backendOrganization.backendBuckets.flatten()
        val buildResults = neededBackendIds.associateWith { neededBackendId ->
            buildBackend(
                backendId = neededBackendId,
                diagnosticPreferences = diagnosticPreferences,
                inputs = inputs,
                logSink = logSink,
                outputRoot = outputRoot,
                preparedModules = preparedModules,
                test = test,
            )
        }

        val buildResult = buildResults.getValue(backendId)

        @Suppress("UNCHECKED_CAST")
        val backend = buildResult.backend as BACKEND

        val taskName = test.testName
        val request = if (test.runAsTest) {
            RunTestsRequest(
                libraries = setOf(test.libraryName),
                taskName = taskName,
            )
        } else {
            RunLibraryRequest(
                libraryName = test.libraryName,
                taskName = taskName,
            )
        }
        val specializedRequest = request
            .specializeForBackend(backendId, dependencies = backend.getDependencies())
            ?: fail("Could not specialize request $request")

        runGeneratedCode(
            buildResults,
            buildResult.allModules,
            outputRoot,
            buildResult.mainOutputDir,
            buildResult.outputPaths,
            test,
            specializedRequest,
        )
    }

    /** This build might or might not be for the main backend for the test runner. */
    private fun<B : Backend<B>> buildBackend(
        backendId: BackendId,
        diagnosticPreferences: FunctionalTestDiagnosticPreferences,
        inputs: List<Pair<FilePath, String>>,
        logSink: ListBackedLogSink,
        outputRoot: OutputRoot,
        preparedModules: PreparedFunctionalTest,
        test: FunctionalTestBase,
    ) = run {
        val supportedBackendList = listOf(backendId)
        val functionalTestLibraryConfiguration = LibraryConfiguration(
            libraryRoot = test.projectRoot,
            libraryName = test.libraryName,
            supportedBackendList = supportedBackendList,
            classifyTemperSource = {
                if (isTemperFile(it.fullName)) {
                    languageConfigForExtension(it.extension)
                } else {
                    null
                }
            },
        )

        val libraryConfigurationsBundle =
            // TODO(mikesamuel): do we need the testing library and others in here?
            LibraryConfigurationsBundle.from(
                preparedModules.libraryConfigurations.map {
                    it.copy(supportedBackendList = supportedBackendList)
                },
            )

        val needsBundling = backendId.needsHackyBundlingHack
        val config = if (needsBundling) {
            Backend.Config.bundledWithMeta
        } else {
            Backend.Config.production
        }

        val partitionedModules =
            if (needsBundling) {
                val modules = preparedModules.modules
                // Instead of just bundling (test.projectRoot to modules)
                // we cherry-pick which other modules are needed.  This
                // works around issue #1946 which triggers when
                // we bring all of std in for the regexMatch functional test.
                val moduleLocationToModulesIndex = buildMap {
                    modules.indices.forEach { this[modules[it].loc] = it }
                }
                // Build up a list of the indices needed transitively following import
                // records so that we can take the portion of modules, in order, that
                // we need.
                val moduleIndicesNeeded = mutableSetOf<Int>()
                fun need(moduleIndex: Int) {
                    if (moduleIndex !in moduleIndicesNeeded) {
                        moduleIndicesNeeded.add(moduleIndex)
                        for (importRecord in modules[moduleIndex].importRecords) {
                            val expLoc = importRecord.exporterLocation
                            moduleLocationToModulesIndex[expLoc]?.let { exporterIndex ->
                                need(exporterIndex)
                            }
                        }
                    }
                }
                for ((moduleIndex, module) in modules.withIndex()) {
                    when (val loc = module.loc) {
                        ImplicitsCodeLocation -> {}
                        is ModuleName -> {
                            if (loc.libraryRoot() == test.projectRoot) {
                                need(moduleIndex)
                            }
                        }
                    }
                }
                mapOf(
                    test.projectRoot to
                        (functionalTestLibraryConfiguration to moduleIndicesNeeded.sorted().map { modules[it] }),
                )
            } else {
                preparedModules.partitionedModules
            }
        val allModules = partitionedModules.values.flatMap { it.second }

        maybePrintDiagnosticsFromTmpL(allModules, diagnosticPreferences)

        val outputDirs = partitionedModules.mapValues { (root, _) ->
            val libraryConfiguration = libraryConfigurationsBundle.byLibraryRoot.getValue(root)
            val backendLib = dirPath(
                backendId.uniqueId,
                libraryConfiguration.libraryName.text,
            )
            outputRoot.makeDirs(backendLib) to outputRoot.makeDir(temperKeepSegment).makeDirs(backendLib)
        }
        val dependenciesBuilder = Dependencies.Builder<B>(
            libraryConfigurationsBundle,
        )

        @Suppress("UNCHECKED_CAST")
        val factory = lookupFactory(backendId) as Backend.Factory<B>
        val backends = partitionedModules.mapValues { (root, lib) ->
            val (libraryConfiguration, modules) = lib
            val (outputDir, keepDir) = outputDirs.getValue(root)

            factory.make(
                BackendSetup(
                    libraryName = libraryConfiguration.libraryName,
                    modules = modules,
                    buildFileCreator = outputDir.systemAccess(cancelGroup),
                    keepFileUpdater = keepDir.systemReadAccess(cancelGroup),
                    logSink = logSink,
                    dependencyResolver = NullDependencyResolver,
                    config = config,
                    dependenciesBuilder = dependenciesBuilder,
                ),
            )
        }
        val backendInfos = applyBackendsSynchronously(cancelGroup, backends.values.toList())
        maybePrintDiagnosticsFromBackends(backendInfos, diagnosticPreferences)

        // Check for errors *after* generating backend code, in case there were more errors.
        checkStaticErrors(test, logSink)

        val outputPaths = buildMap {
            backendInfos.forEach { info ->
                info.tmpL.modules.forEach {
                    put(it.codeLocation.codeLocation, it.codeLocation.outputPath)
                }
            }
        }

        if (logSink.hasFatal) {
            val sources = inputs.associate { (path, source) ->
                path to (source to FilePositions.fromSource(loc = path, input = source))
            }

            val withGrammarProblems = logSink.allEntries
                .filter {
                    it.level >= Log.Error &&
                        (it.template as? MessageTemplate)?.stage ==
                        CompilationPhase.TreeBuild
                }
                .map { it.pos.loc }
                .toSet()
            if (withGrammarProblems.isNotEmpty()) {
                console.error("Concrete syntax trees")
                for (module in allModules) {
                    if (module.loc in withGrammarProblems) {
                        console.log("/* ${module.loc.diagnostic}*/")
                        val tots = TextOutputTokenSink(console.textOutput)
                        for (source in module.sources) {
                            // TODO Also give source path for each if present?
                            val cst = source.cst
                            if (cst != null) {
                                TemperFormattingHints.makeFormattingTokenSink(
                                    tots,
                                    singleLine = false,
                                ).use {
                                    cst.renderTo(it)
                                }
                            } else {
                                console.error("CST unavailable")
                            }
                        }
                    }
                }
            }

            logSink.toConsole(console, Log.Warn, sources)

            dumpModuleBodies(allModules)
            fail("Code generation failed with fatal errors")
        }

        // Allow referring to FooBackend instead of Backend<FooBackend> in
        // implementations.
        @Suppress("UNCHECKED_CAST")
        val backend = backends.getValue(functionalTestLibraryConfiguration.libraryRoot)

        val (mainOutputDir, _) = outputDirs.getValue(functionalTestLibraryConfiguration.libraryRoot)
        BuildResult(
            allModules = allModules,
            backend = backend,
            mainOutputDir = mainOutputDir,
            outputPaths = outputPaths,
        )
    }

    open fun runGeneratedCode(
        buildResults: Map<BackendId, BuildResult>,
        modules: List<Module>,
        outputRoot: OutputRoot,
        outputDir: OutDir,
        outputPaths: Map<ModuleName, FilePath>,
        test: FunctionalTestBase,
        request: ToolchainRequest,
    ) {
        @Suppress("UNCHECKED_CAST")
        val backend = buildResults.getValue(backendId).backend as BACKEND
        runGeneratedCode(backend, modules, outputRoot, outputDir, outputPaths, test, request)
    }

    protected open fun runGeneratedCode(
        backend: BACKEND,
        modules: List<Module>,
        outputRoot: OutputRoot,
        outputDir: OutDir,
        outputPaths: Map<ModuleName, FilePath>,
        test: FunctionalTestBase,
        request: ToolchainRequest,
    ) {
        error("Build results expected for multiple backends")
    }

    fun dumpModuleBodies(modules: List<Module>) {
        for (module in modules) {
            console.group("/* ${module.loc.diagnostic} */") {
                module.generatedCode?.toPseudoCode(
                    console.textOutput,
                    singleLine = false,
                    detail = PseudoCodeDetail(showInferredTypes = true),
                )
                console.textOutput.endLine()
            }
        }
    }

    companion object {
        private val server = TestWebServer()

        @BeforeAll
        @JvmStatic
        fun startServer() = server.start()

        @AfterAll
        @JvmStatic
        fun stopServer() = server.stop()
    }
}

class BuildResult(
    val allModules: List<Module>,
    val backend: Backend<*>,
    val mainOutputDir: OutDir,
    val outputPaths: Map<ModuleName, FilePath>,
)

object NullDependencyResolver : DependencyResolver {
    override fun resolve(
        loc: ModuleLocation,
        backendId: BackendId,
        logSink: LogSink,
    ): JsonValue? = null
}

private fun maybePrintDiagnosticsFromTmpL(
    modules: List<Module>,
    diagnosticPreferences: FunctionalTestDiagnosticPreferences,
) {
    if (mightDoSomething(diagnosticPreferences.shouldPrintModule)) {
        val toPrint = modules.filter(diagnosticPreferences.shouldPrintModule)
        if (toPrint.isNotEmpty()) {
            console.group("Prepared modules") {
                for (module in toPrint) {
                    console.group("${module.loc}") {
                        module.generatedCode?.toPseudoCode(console.textOutput)
                        console.textOutput.endLine()
                    }
                }
            }
        }
    }
}

private fun maybePrintDiagnosticsFromBackends(
    backendInfos: List<BackendInfo<*>>,
    diagnosticPreferences: FunctionalTestDiagnosticPreferences,
) {
    val shouldPrintFinishedTmpL = diagnosticPreferences.shouldPrintFinishedTmpL
    val shouldPrintOutputFile = diagnosticPreferences.shouldPrintOutputFile
    if (
        !mightDoSomething(shouldPrintFinishedTmpL) &&
        !mightDoSomething(shouldPrintOutputFile)
    ) {
        return
    }

    val tmpLToPrint = mutableMapOf<DashedIdentifier, List<TmpL.Module>>()
    val outputFilesToPrint = mutableMapOf<DashedIdentifier, List<Backend.OutputFileSpecification>>()
    backendInfos.forEach { info ->
        val libraryName = info.backend.libraryConfigurations.currentLibraryConfiguration.libraryName

        val tmpLModules = info.tmpL.modules.filter(shouldPrintFinishedTmpL)
        if (tmpLModules.isNotEmpty()) {
            val prev = tmpLToPrint[libraryName] ?: emptyList()
            tmpLToPrint[libraryName] = prev + tmpLModules
        }

        val outputFiles = info.outputFiles.filter(shouldPrintOutputFile)
        if (outputFiles.isNotEmpty()) {
            val prev = outputFilesToPrint[libraryName] ?: emptyList()
            outputFilesToPrint[libraryName] = prev + outputFiles
        }
    }

    if (tmpLToPrint.isNotEmpty()) {
        console.group("Finished TmpL") {
            tmpLToPrint.forEach { (lib, tmpLModules) ->
                console.group("Library $lib") {
                    for (tmpLModule in tmpLModules) {
                        console.group("${tmpLModule.codeLocation.codeLocation}") {
                            printTree(tmpLModule, console.textOutput)
                        }
                    }
                }
            }
        }
    }

    if (outputFilesToPrint.isNotEmpty()) {
        console.group("Output files") {
            outputFilesToPrint.forEach { (lib, files) ->
                console.group("Library $lib") {
                    for (file in files) {
                        console.group(
                            "${file.path}${
                                if (file.mimeType != null) " : ${file.mimeType}" else ""
                            }",
                        ) {
                            when (file) {
                                is Backend.ByteArrayFileSpecification -> {
                                    val contentHash = ContentHash.fromBytes(
                                        "SHA-256",
                                        file.content,
                                    )
                                    when (contentHash) {
                                        is RFailure -> console.warn("FAILED TO HASH ${contentHash.failure.message}")
                                        is RSuccess -> console.log("HASH ${contentHash.result}")
                                    }
                                }
                                is Backend.MetadataFileSpecification ->
                                    console.log(file.content)
                                is Backend.ResourceFileSpecification ->
                                    console.log("Resource ${file.content.fileName}")
                                is Backend.TranslatedFileSpecification ->
                                    printTree(file.content as BaseOutTree<*>, console.textOutput)
                            }
                        }
                    }
                }
            }
        }
    }
}

private fun printTree(
    outTree: BaseOutTree<*>,
    textOutput: TextOutput,
) {
    val sink = outTree.formattingHints().makeFormattingTokenSink(
        TextOutputTokenSink(textOutput),
        singleLine = false,
    )
    outTree.formatTo(sink)
    sink.finish()
    textOutput.endLine()
    textOutput.flush()
}

/** Specifically reverts test naming per Java and C# backends. Maybe others. */
fun assertTestingTest(
    test: FunctionalTestBase,
    result: RResult<EffortSuccess, CliFailure>,
    /** To reverse the test naming and normalize the human case. */
    testPattern: Regex = Regex("""(.*?)(?:__\d+)?"""),
) {
    // TODO Extract more of the common logic that applies to all backends.
    val effort = result.effort() as EffortSuccess
    val junitOutput = effort.auxOut[Aux.JunitXml]
    assertTestingTestFromJunit(test, junitOutput, effort.stdout, testPattern)
}
