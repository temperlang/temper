package lang.temper.name

import lang.temper.common.MimeType
import lang.temper.log.bannedPathSegmentNames
import lang.temper.log.isProblematicInFilePathSegment

/**
 * A globally unique identifier for a Temper backend.
 *
 * When a Temper backend becomes supported, its [BackendId.uniqueId] should be added to this table.
 *
 * | uniqueId   | Implementation                |
 * | ---------- | ----------------------------- |
 * | `js`       | [lang.temper.be.js.JsBackend] |
 * | `py`       | [lang.temper.be.py.PyBackend] |
 *
 * This table should be kept up-to-date with `defaultSupportedBackendList.kt` and the list of
 * backend IDs in `functional-test-suite/.../AllTestsTest.kt`
 */
data class BackendId(
    /**
     * A string that uniquely identifies the backend.
     * This should be valid text for a [file path segment][lang.temper.log.FilePathSegment] so that
     * the compiler can create a subdirectory of `temper.out` for files produced by the associated
     * backend.
     *
     * Since some file systems are case-insensitive, two backends must not have backendIds that
     * differ only by ASCII case.
     *
     * This string must also not end in `.deleting` so that a compiler may rename a directory
     * to `originalName.deleting` while it coordinates building the new files and a background
     * job recursively deletes the old files.
     */
    val uniqueId: String,
) : Comparable<BackendId> {
    init {
        require(
            uniqueId.isNotEmpty() &&
                uniqueId !in bannedPathSegmentNames &&
                !uniqueId.any { isProblematicInFilePathSegment(it) } &&
                !dotDeletingCaseInsensitive.containsMatchIn(uniqueId),
        )
    }

    override fun compareTo(other: BackendId): Int = uniqueId.compareTo(other.uniqueId)
    override fun toString() = uniqueId
}

/**
 * Standard metadata describing a backend with a given [BackendId]
 */
data class BackendMeta(
    /** The identifier selecting the backend this metadata describes. */
    val backendId: BackendId,
    /** The descriptor for the language generated by this backend. */
    val languageLabel: LanguageLabel,
    /** Identify specific file extensions by the abstract file type. */
    val fileExtensionMap: Map<FileType, String>,
    /**
     * A set of mime-types produced, so a backend manager could pick appropriate backends based on
     * accepted types.
     */
    val mimeTypeMap: Map<FileType, MimeType>,
    /** Backends that this backend also needs to build with. */
    val requiredBackendIds: List<BackendId> = listOf(),
) {
    init {
        require(fileExtensionMap.values.all { it.startsWith(".") }) { fileExtensionMap }
    }

    /**
     * A set of mime-types produced, so a backend manager could pick appropriate backends based on
     * accepted types.
     */
    val mimeTypes: Set<MimeType> get() = mimeTypeMap.values.toSet()
}

/** The various source-code file types. */
enum class FileType {
    /** the generic module we're creating */
    Module,

    /** a special case for .mjs files */
    JsModule,

    /** a script or application to run */
    Script,
}

/** Language labels may be equal to a backend's unique ID, unless multiple backends produce the same language */
data class LanguageLabel(val label: String) {
    override fun toString(): String = label
}

/** See [lang.temper.fs.DOT_DELETING_PREFIX] */
private val dotDeletingCaseInsensitive = Regex("^[.]deleting|[.]deleting$", RegexOption.IGNORE_CASE)

val interpBackendId = BackendId("interp")
