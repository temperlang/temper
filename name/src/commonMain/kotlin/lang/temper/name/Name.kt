package lang.temper.name

import lang.temper.common.backtickTemperEscaper
import lang.temper.common.structure.Hints
import lang.temper.common.structure.StructureSink
import lang.temper.common.structure.Structured
import lang.temper.common.toStringViaBuilder
import lang.temper.format.OutputTokenType
import lang.temper.format.TokenSerializable
import lang.temper.format.TokenSink
import lang.temper.lexer.Lexer
import lang.temper.lexer.LexicalDefinitions
import lang.temper.lexer.TokenType
import lang.temper.lexer.isUnreservedIdentifier
import lang.temper.lexer.nextNotSyntheticOrNull
import lang.temper.log.LogSink
import lang.temper.log.SimplifiesInLogMessage
import lang.temper.log.UnknownCodeLocation

/** Base type for a name. */
sealed interface Name : Structured, TokenSerializable {
    /** A key that can be used to look up a builtin definition. */
    val builtinKey: String?

    /**
     * Best effort to convert to a symbol.  Names that do not originate in source text may not
     * be convertible.
     */
    fun toSymbol(): Symbol?

    /**
     * A possibly ambiguous diagnostic, although likely more unique than [displayName].
     * Two [Name]s with the same diagnostic are not necessarily the same reference,
     * and since diagnostics can include non-normative info, two with distinct diagnostics are
     * not necessarily different references.
     */
    val rawDiagnostic: String

    /**
     * The base name if that exists, matching [toSymbol] if so.
     * Otherwise, a best effort simple name for display.
     * As with [rawDiagnostic], this value might not be unique.
     * It merely exists for human prettiness.
     */
    val displayName: String get() = safeDiagnostic(rawDiagnostic)

    fun toToken(
        /**
         * A Temper name whose text is "-" can be rendered as `-` if it's used in
         * operator position, but needs to be rendered as <code>nym\`-\`</code> otherwise.
         */
        inOperatorPosition: Boolean,
    ): NameOutputToken

    override fun renderTo(tokenSink: TokenSink) {
        tokenSink.emit(toToken(inOperatorPosition = false))
    }
}

/**
 * A name that might appear in a Temper AST.
 *
 * Temper names are broadly divided into two groups:
 * - [ParsedName]s which are produced by the lexer and parser and which survive until the name
 *   resolution pass during the [syntax macro stage][lang.temper.stage.Stage.SyntaxMacro]
 * - [ResolvedName]s which are resolved from parsed names by matching uses with declarations so
 *   that later passes do not need to preserve the relationship between AST subtree containment
 *   and lexical scoping, and so that names in subtrees generated by macros do not unintentionally
 *   conflict with local names.
 */
sealed interface TemperName : Name {
    override fun toToken(inOperatorPosition: Boolean): NameOutputToken {
        val rawDiagnostic = this.rawDiagnostic
        val (text, type) = nameToTokenParts(
            rawDiagnostic,
            allowPunctuation = inOperatorPosition,
        )
        return NameOutputToken(
            name = this,
            inOperatorPosition = inOperatorPosition,
            text = text,
            type = type,
        )
    }
}

/** A [TemperName] that is stable across compiler runs. */
sealed interface StableTemperName : TemperName

/** A name parsed from a source text that has yet to be resolved to a declaration. */
data class ParsedName(val nameText: String) : TemperName {
    override val builtinKey get() = nameText

    override fun toSymbol() = Symbol(nameText)

    override fun destructure(structureSink: StructureSink) = structureSink.value(nameText)

    override fun toString(): String = nameText

    override val rawDiagnostic: String get() = nameText
}

/**
 * A name that has been resolved based on scoping rules, and is no longer dependent on identifier
 * text.
 */
sealed interface ResolvedName : TemperName

/**
 * A [resolved name][ResolvedName] that was derived from a [parsed name][ParsedName].
 */
sealed interface ResolvedParsedName : ResolvedName, SimplifiesInLogMessage {
    val baseName: ParsedName

    override val simplerLoggable get() = baseName
}

/**
 * Modular names refer to things defined within their origin (aka module).
 */
sealed class ModularName : ResolvedName {
    abstract val origin: NamingContext

    fun comesFrom(otherOrigin: NamingContext?) = origin === otherOrigin
}

/**
 * Internal modular names may change as different versions of the module are compiled.
 * They do not need to be stable across versions.
 */
sealed class InternalModularName : ModularName() {
    abstract val uid: Int
}

/**
 * Builtin names do not refer to anything defined by the module.
 * They mat resolve to declarations in:
 * 1. Stage specific macros as per the [lang.temper.frontend.interpretiveDanceStage]
 * 2. The module's context environment which includes definitions like `import` and `export` which
 *    need to close over the module's path to resolve relative references, and which contains
 *    definitions provided by that which caused the module to load, including trusted modules.
 * 3. [lang.temper.interp.BuiltinEnvironment] which contains powerless language builtins.
 */
class BuiltinName(
    override val builtinKey: String,
) : ResolvedParsedName, StableTemperName {
    override val rawDiagnostic: String get() = builtinKey

    override val baseName: ParsedName get() = ParsedName(builtinKey)

    // TODO Should BuiltinName also override displayName to avoid nym`...`?

    override fun destructure(structureSink: StructureSink) {
        structureSink.value(builtinKey)
    }

    override fun equals(other: Any?): Boolean =
        other is BuiltinName && this.builtinKey == other.builtinKey

    override fun hashCode(): Int = builtinKey.hashCode() xor 0x1bbf21c4

    override fun toSymbol(): Symbol = Symbol(builtinKey)

    override fun toString(): String = safeDiagnostic(builtinKey)
}

/** A name synthesized by the compiler. */
class Temporary private constructor(
    override val origin: NamingContext,
    override val uid: Int,
    val nameHint: String,
) : InternalModularName() {
    override val rawDiagnostic get() = "$nameHint#$uid"

    override fun toString(): String = safeDiagnostic(rawDiagnostic)

    override fun equals(other: Any?): Boolean =
        other is Temporary && this.comesFrom(other.origin) && this.uid == other.uid

    override fun hashCode() = this.origin.hashCode() + 31 * this.uid

    internal constructor(
        origin: NamingContext,
        nameHint: String = defaultNameHint,
    ) : this(origin = origin, uid = NamingContext.newNameUid(origin), nameHint = nameHint)

    internal constructor(
        baseName: InternalModularName,
    ) : this(baseName.origin, baseName.rawDiagnostic)

    override fun destructure(structureSink: StructureSink) = structureSink.obj {
        key("type", Hints.u) { value("Temporary") }
        key("origin", Hints.u) { value(origin.loc) }
        key("uid") { value(uid) }
        key("nameHint", Hints.u) { value(nameHint) }
        key("abbrev", Hints.su) { value(rawDiagnostic) }
    }

    override val builtinKey: String? get() = null

    override fun toSymbol(): Symbol? = null

    companion object {
        const val defaultNameHint = "t"
    }
}

/**
 * A name corresponding to identifiers in source code.
 *
 * We bend this rule a bit: we synthesize names for anonymous classes.
 */
class SourceName private constructor(
    override val origin: NamingContext,
    override val uid: Int,
    override val baseName: ParsedName,
) : InternalModularName(), ResolvedParsedName {
    internal constructor(
        origin: NamingContext,
        baseName: ParsedName,
    ) : this(origin, NamingContext.newNameUid(origin), baseName)

    /** Possibly ambiguous diagnostic string. */
    override val rawDiagnostic: String get() = "${baseName.nameText}__$uid"

    override val displayName: String get() = safeDiagnostic(baseName.nameText)

    override fun toString() = safeDiagnostic(rawDiagnostic)

    override fun equals(other: Any?): Boolean =
        other is SourceName && this.origin == other.origin && this.uid == other.uid

    override fun hashCode(): Int = origin.hashCode() + 31 * uid

    override fun destructure(structureSink: StructureSink) = structureSink.obj {
        key("type", Hints.u) { value("SourceName") }
        key("module", Hints.u) { value(origin.loc) }
        key("uid") { value(uid) }
        key("nameHint", Hints.u) { value(baseName.nameText) }
        key("abbrev", Hints.su) { value(rawDiagnostic) }
    }

    override val builtinKey: String? get() = null

    override fun toSymbol(): Symbol = baseName.toSymbol()
}

/**
 * A stable name associated with an origin.
 * This is the name for an export.
 */
class ExportedName(
    override val origin: NamingContext,
    override val baseName: ParsedName,
) : ModularName(), StableTemperName, ResolvedParsedName {
    /** Possibly ambiguous diagnostic string. */
    override val rawDiagnostic: String get() = baseName.nameText

    override fun toString() = toStringViaBuilder { sb ->
        sb.append(origin.locationDiagnostic)
        sb.append('.')
        sb.append(safeDiagnostic(rawDiagnostic))
    }

    override fun equals(other: Any?): Boolean =
        other is ExportedName && this.origin == other.origin && this.baseName == other.baseName

    override fun hashCode(): Int = origin.hashCode() + 31 * baseName.hashCode()

    override fun destructure(structureSink: StructureSink) = structureSink.obj {
        key("type", Hints.u) { value("ExportedName") }
        val exporter = origin.loc
        key("module", Hints.u) { value(exporter) }
        key("baseName", Hints.u) { value(baseName.nameText) }
        key("abbrev", Hints.su) {
            value(
                toStringViaBuilder {
                    it.append(exporter.diagnostic)
                    it.append('.')
                    it.append(baseName.nameText)
                },
            )
        }
    }

    override val builtinKey: String? get() = null

    override fun toSymbol(): Symbol = baseName.toSymbol()
}

/**
 * A name in an output language that corresponds to a name in Temper.
 */
class OutName(
    /**
     * For OutNames, we have to trust the Backend to produce safe name texts because
     * [LexicalDefinitions.quotedNamePrefix] is not a valid way to quote non-Temper names.
     */
    val outputNameText: String,
    sourceName: Name?,
) : Name {
    val sourceName: Name? = when (val sn = sourceName) {
        is OutName -> sn.sourceName
        else -> sn
    }

    override val builtinKey: String? get() = null

    override fun toSymbol(): Symbol? = null

    override val rawDiagnostic: String get() = outputNameText

    override fun destructure(structureSink: StructureSink) = structureSink.obj {
        key("outputNameText") { value(outputNameText) }
        key("sourceName") { value(sourceName) }
    }

    override fun toToken(inOperatorPosition: Boolean) =
        NameOutputToken(
            name = this,
            inOperatorPosition = inOperatorPosition,
            text = outputNameText,
            type = OutputTokenType.Name,
        )

    override fun toString(): String = outputNameText

    override fun hashCode(): Int = outputNameText.hashCode()
    override fun equals(other: Any?): Boolean = other is OutName && this.outputNameText == other.outputNameText
}

/** Convenience like [TokenSink.quoted] */
fun TokenSink.name(name: Name, inOperatorPosition: Boolean) {
    emit(name.toToken(inOperatorPosition = inOperatorPosition))
}

private fun safeDiagnostic(nameText: String) =
    if (isUnreservedIdentifier(nameText)) {
        nameText
    } else {
        toStringViaBuilder { out ->
            out.append(LexicalDefinitions.quotedNamePrefix)
            backtickTemperEscaper.escapeTo(nameText, out = out)
        }
    }

private fun nameToTokenParts(
    diagnostic: String,
    allowPunctuation: Boolean,
): Pair<String, OutputTokenType> {
    val type: OutputTokenType
    val text: String

    val isUnreservedIdentifier = isUnreservedIdentifier(diagnostic)
    if (isUnreservedIdentifier) {
        type = OutputTokenType.Name
        text = diagnostic
    } else if (allowPunctuation && (diagnostic == "/" || diagnostic == "/=")) {
        // Division / regex ambiguity bites below
        type = OutputTokenType.Punctuation
        text = diagnostic
    } else {
        val isPunctuation = allowPunctuation && run {
            // If it doesn't lex as a full punctuation token, then we need to back-quote.
            val lexer = Lexer(UnknownCodeLocation, LogSink.devNull, diagnostic)
            val token = lexer.nextNotSyntheticOrNull
            token != null && token.tokenText == diagnostic && token.tokenType == TokenType.Punctuation
        }
        if (isPunctuation) {
            type = OutputTokenType.Punctuation
            text = diagnostic
        } else {
            type = OutputTokenType.QuotedValue
            text = toStringViaBuilder {
                it.append(LexicalDefinitions.quotedNamePrefix)
                backtickTemperEscaper.escapeTo(diagnostic, it)
            }
        }
    }
    return Pair(text, type)
}
