@file:lang.temper.common.Generated("FunctionalTestSuitener")
@file:Suppress("ktlint")

package lang.temper.tests
import lang.temper.common.console
import lang.temper.common.currents.CancelGroup
import lang.temper.name.BackendId
import org.junit.jupiter.api.Timeout
import kotlin.test.Test

typealias Ft = FunctionalTests

/**
 * Autogenerated file, to update use `./gradlew kcodegen:up`, to update these docs, see:
 * `kcodegen/src/commonMain/kotlin/lang/temper/kcodegen/functests/FunctionalTestSuiteITemplate.kt`.
 *
 * Has a method per test-case in [FunctionalTests] to make it easier to keep test suites up-do-date with
 * a test method per.  This makes for nicer test reports and provides IDE UI elements for easy
 * test running.
 *
 * All these tests must be defined here; backends do not have to define them. To inspect a specific test on a
 * backend, there are two options:
 *
 * 1. Override the method on the backend
 *    - Alt-Shift-O for Override methods
 *    - Select the test to override
 *    - Edit to run the desired test, e.g.
 *    ```kotlin
 *    @Test
 *    override fun helloWorld() = runFunctionalTest(FunctionalTests.HelloWorld)
 *    ```
 * 2. Manually edit a gradle configuration:
 *    - Run the "allTests" test
 *    - Control-Shift A and "Edit Configurations"
 *    - Duplicate the configuration created for "allTests"
 *    - Change the argument, e.g. `--tests "lang.temper.be.js.JsFunctionalTests.allTests"`
 *      to `--tests "lang.temper.be.js.JsFunctionalTests.helloWorld"`
 */
@Timeout(TIMEOUT)
interface FunctionalTestSuiteI {
    val cancelGroup: CancelGroup

    /** Runs a specific test. */
    fun runFunctionalTest(
        test: FunctionalTestBase,
        verbose: Boolean = false,
    )

    /** The backend this test runner is running against. */
    val backendId: BackendId

    fun runFunctionalTest(
        test: FunctionalTests,
        runOverride: Disposition? = null,
        verbose: Boolean = false,
    ) {
        if ((runOverride ?: test.disposition(backendId)) is Disposition.Skip) {
            console.info("Skipping ${test.name}")
        } else {
            runFunctionalTest(test.test, verbose)
        }
    }

    /**
     * Test methods are updated via `./gradlew kcodegen:up`.
     */
    @Test
    fun algosFibonacci() =
        runFunctionalTest(Ft.AlgosFibonacci)

    @Test
    fun algosHelloFromClassToTop() =
        runFunctionalTest(Ft.AlgosHelloFromClassToTop)

    @Test
    fun algosHelloWorld() =
        runFunctionalTest(Ft.AlgosHelloWorld)

    @Test
    fun algosHelloWorldObject() =
        runFunctionalTest(Ft.AlgosHelloWorldObject)

    @Test
    fun algosMyersDiff() =
        runFunctionalTest(Ft.AlgosMyersDiff)

    @Test
    fun castsAsExpr() =
        runFunctionalTest(Ft.CastsAsExpr)

    @Test
    fun castsSpecific() =
        runFunctionalTest(Ft.CastsSpecific)

    @Test
    fun classesAngleCall() =
        runFunctionalTest(Ft.ClassesAngleCall)

    @Test
    fun classesCallOverrideFromSubtype() =
        runFunctionalTest(Ft.ClassesCallOverrideFromSubtype)

    @Test
    fun classesDirectGetter() =
        runFunctionalTest(Ft.ClassesDirectGetter)

    @Test
    fun classesInheritedGetter() =
        runFunctionalTest(Ft.ClassesInheritedGetter)

    @Test
    fun classesObjectLiterals() =
        runFunctionalTest(Ft.ClassesObjectLiterals)

    @Test
    fun classesPrivateMethod() =
        runFunctionalTest(Ft.ClassesPrivateMethod)

    @Test
    fun classesPropertyOrder() =
        runFunctionalTest(Ft.ClassesPropertyOrder)

    @Test
    fun classesSetters() =
        runFunctionalTest(Ft.ClassesSetters)

    @Test
    fun classesStaticProperties() =
        runFunctionalTest(Ft.ClassesStaticProperties)

    @Test
    fun classesStaticPropertiesScope() =
        runFunctionalTest(Ft.ClassesStaticPropertiesScope)

    @Test
    fun controlFlowActorRun() =
        runFunctionalTest(Ft.ControlFlowActorRun)

    @Test
    fun controlFlowAsync() =
        runFunctionalTest(Ft.ControlFlowAsync)

    @Test
    fun controlFlowBubble() =
        runFunctionalTest(Ft.ControlFlowBubble)

    @Test
    fun controlFlowIfReturn() =
        runFunctionalTest(Ft.ControlFlowIfReturn)

    @Test
    fun controlFlowLoopReenterable() =
        runFunctionalTest(Ft.ControlFlowLoopReenterable)

    @Test
    fun controlFlowLoops() =
        runFunctionalTest(Ft.ControlFlowLoops)

    @Test
    fun functionsAsValues() =
        runFunctionalTest(Ft.FunctionsAsValues)

    @Test
    fun functionsConstructorCallbacks() =
        runFunctionalTest(Ft.FunctionsConstructorCallbacks)

    @Test
    fun functionsDefaulting() =
        runFunctionalTest(Ft.FunctionsDefaulting)

    @Test
    fun functionsLocals() =
        runFunctionalTest(Ft.FunctionsLocals)

    @Test
    fun functionsNamedArgs() =
        runFunctionalTest(Ft.FunctionsNamedArgs)

    @Test
    fun functionsRestFormal() =
        runFunctionalTest(Ft.FunctionsRestFormal)

    @Test
    fun functionsSimpleLocals() =
        runFunctionalTest(Ft.FunctionsSimpleLocals)

    @Test
    fun importsFunctions() =
        runFunctionalTest(Ft.ImportsFunctions)

    @Test
    fun importsTypes() =
        runFunctionalTest(Ft.ImportsTypes)

    @Test
    fun importsValues() =
        runFunctionalTest(Ft.ImportsValues)

    @Test
    fun interfacesEmpty() =
        runFunctionalTest(Ft.InterfacesEmpty)

    @Test
    fun interfacesPropertyMembers() =
        runFunctionalTest(Ft.InterfacesPropertyMembers)

    @Test
    fun interfacesPureVirtual() =
        runFunctionalTest(Ft.InterfacesPureVirtual)

    @Test
    fun namesNonascii() =
        runFunctionalTest(Ft.NamesNonascii)

    @Test
    fun regexMatch() =
        runFunctionalTest(Ft.RegexMatch)

    @Test
    fun regexZeroAdvance() =
        runFunctionalTest(Ft.RegexZeroAdvance)

    @Test
    fun regressionMinimalRepro() =
        runFunctionalTest(Ft.RegressionMinimalRepro)

    @Test
    fun semanticsBroken() =
        runFunctionalTest(Ft.SemanticsBroken)

    @Test
    fun semanticsConstness() =
        runFunctionalTest(Ft.SemanticsConstness)

    @Test
    fun semanticsMutuallyReferencingTypes() =
        runFunctionalTest(Ft.SemanticsMutuallyReferencingTypes)

    @Test
    fun semanticsTypeCheckedLocals() =
        runFunctionalTest(Ft.SemanticsTypeCheckedLocals)

    @Test
    fun testingAsserts() =
        runFunctionalTest(Ft.TestingAsserts)

    @Test
    fun typesDate() =
        runFunctionalTest(Ft.TypesDate)

    @Test
    fun typesDenseBitVector() =
        runFunctionalTest(Ft.TypesDenseBitVector)

    @Test
    fun typesDeque() =
        runFunctionalTest(Ft.TypesDeque)

    @Test
    fun typesFloatBasics() =
        runFunctionalTest(Ft.TypesFloatBasics)

    @Test
    fun typesFloatOps() =
        runFunctionalTest(Ft.TypesFloatOps)

    @Test
    fun typesIntBasics() =
        runFunctionalTest(Ft.TypesIntBasics)

    @Test
    fun typesIntLimits() =
        runFunctionalTest(Ft.TypesIntLimits)

    @Test
    fun typesJsonSyntaxTree() =
        runFunctionalTest(Ft.TypesJsonSyntaxTree)

    @Test
    fun typesListEmpty() =
        runFunctionalTest(Ft.TypesListEmpty)

    @Test
    fun typesListOperations() =
        runFunctionalTest(Ft.TypesListOperations)

    @Test
    fun typesListReduce() =
        runFunctionalTest(Ft.TypesListReduce)

    @Test
    fun typesListSorting() =
        runFunctionalTest(Ft.TypesListSorting)

    @Test
    fun typesMap() =
        runFunctionalTest(Ft.TypesMap)

    @Test
    fun typesNetresponse() =
        runFunctionalTest(Ft.TypesNetresponse)

    @Test
    fun typesStringBuild() =
        runFunctionalTest(Ft.TypesStringBuild)

    @Test
    fun typesStringIndices() =
        runFunctionalTest(Ft.TypesStringIndices)

    @Test
    fun typesStringIsEmpty() =
        runFunctionalTest(Ft.TypesStringIsEmpty)

    @Test
    fun typesStringRead() =
        runFunctionalTest(Ft.TypesStringRead)
}

private const val TIMEOUT = 60L
