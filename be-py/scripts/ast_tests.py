## A series of tests that can be parsed by Python into standard AST blocks, from which we
## can generate Kotlin test cases for our Kotlin output tree.

## These tests are generated by `make_tests.py` in the same directory.
## Blanks lines and ## should be dropped.
## A single # is the test name, which will be camel-cased

## A line starting with #:import or #:export asserts that those names are required or provided
## If those lines are missing, a test is still created with no names.

# integer literal
7

# integer literal
-3

# integer literal
+3

# float literal
2.125

# float literal
1750000.0
## 1.75e6

# float literal
+2.125

# float literal
-2.125

# string literal
'a string'

# string literal empty
''

# string literal newline
'foo\nbar'

# string literal many newlines
'foo\n\n\nbar\n\n\nqux\n'

# string literal single quote
"foo'bar"

# string literal double quote
'foo"bar'

# string literal CR
'foo\rbar'

# string literal tab
'foo\tbar'

# string literal simple hex
'foo\x9cbar'

# string literal euro symbol
'foo\u20acbar'

# string literal unicode 32
'foo\U0001f796bar'

# constant true
True

# constant false
False

# constant none
None

# constant ellipsis
...

# constant not implemented
NotImplemented

# empty tuple
()

# single tuple
(None,)

# two elements
(None, None)

# attribute
x.a
#:import x

# subscript
x[a]
#:import x, a

# subscript slice
x[ : ]
#:import x

## # subscript slice
## x[::]

# subscript slice start
x[y : ]
#:import x, y

# subscript slice stop
x[ : y]
#:import x, y

# subscript slice step
x[ : : y]
#:import x, y

# call
foo()
#:import foo

# call pos arg
foo(x)
#:import foo, x

# call pos arg 2
foo(x, y)
#:import foo, x, y

# call var arg
foo(x, *y)
#:import foo, x, y

# call var kw arg
foo(*y, **z)
#:import foo, y, z

# call named arg
foo(x, y = 1)
#:import foo, x

# call default arg var
foo(x, *z, y = 1)
#:import foo, x, z

# call default arg kw
foo(x, y = 1, **z)
#:import foo, x, z

# expr add
x + y + z
#:import x, y, z

# expr times
x * y * z
#:import x, y, z

# expr mat mult
x @ y @ z
#:import x, y, z

# expr pow
x ** y ** z
#:import x, y, z

# expr add unary
x + -y
#:import x, y

# expr bool
x and not y or z
#:import x, y, z

# expr bitwise
x & ~y | z
#:import x, y, z

# compare
x < y
#:import x, y

# member
x in y
#:import x, y

# trinary
a if b else c if d else e
#:import a, b, c, d, e

# tuple concat
(1, 2) + (3, 4)

# one item tuple
foo((1,))
#:import foo

# lambda
lambda: ...

# lambda pos arg
lambda x: ...

# lambda pos arg
lambda x: x

# lambda pos arg
lambda x: y
#:import y

# lambda pos arg
lambda x, y: ...

# lambda var arg
lambda x, *y: ...

# lambda var kw arg
lambda *y, **z: ...

# lambda default arg
lambda x, y = a: ...
#:import a

# function default arg var
lambda x, y = 1, *z: ...

# function default arg kw
lambda x, y = 1, **z: ...

# lambda in function args
f(a, lambda x, y: (x, y), b)
#:import f, a, b

# lambda in function args
f(a, lambda x, y: x, b, c)
#:import f, a, b, c

# statement assign
x = 1
#:export x

# statement assign two vars
x = y = 1
#:export x, y

# statement assign starred
(x, *y) = (1, 2, 3)
## complex assignments aren't considered exports

# statement assign starred
(x, *y) = (1, 2, 3)
z = x + y[0]
## no imports because of local defintion
#:export z

# statement assign annotate
x: int = 1
#:export x

# statement augmented assign
x += 1

# statement pass
pass

# statement break
break

# statement continue
continue

# statement delete
del x

# statement delete two
del x, y

# statement return
return

# statement return value
return 1

# statement yield
yield

# statement yield value
yield 1

# statement yield from
yield from x
#:import x

# statement assert
assert 1

# statement assert msg
assert 1, 'foo'

# statement raise
raise

# statement raise name
raise x
#:import x

# statement raise name from
raise x from y
#:import x, y

# statement import
import x

# statement import 2
import x, y

# statement import dotted
import x.y

# statement import as
import x as y

#:export y

# statement from import
from x import y

#:export y

# statement from import dotted
from x.y import z

#:export z

# statement from import relative
from ..x.y import z

#:export z

# statement global
global x

# statement global 2
global x, y

# statement nonlocal
nonlocal x

# statement nonlocal 2
nonlocal x, y

# statement if
if x:
  pass
#:import x

# statement if else
if x:
  pass
else:
  pass
#:import x

# statement if elif else
if x:
  pass
elif y:
  pass
else:
  pass
#:import x, y

# statement while
while x:
  pass
#:import x

# statement while else
while x:
  pass
else:
  pass
#:import x

# statement for
for x in y:
  pass
#:import y

# statement for else
for x in y:
  pass
else:
  pass
#:import y

# statement async for
async for x in y:
  pass
#:import y

# statement async for else
async for x in y:
  pass
else:
  pass
#:import y

# statement try except
try:
  pass
except:
  pass

# statement try except finally
try:
  pass
except:
  pass
finally:
  pass

# statement try finally
try:
  pass
finally:
  pass

# statement try else
try:
  pass
except:
  pass
else:
  pass

# statement try else finally
try:
  pass
except:
  pass
else:
  pass
finally:
  pass

# statement try except 2
try:
  pass
except:
  pass
except:
  pass

# statement try except exception
try:
  pass
except x:
  pass
#:import x

# statement try except exception as
try:
  pass
except x as y:
  pass
#:import x

# statement with
with x:
  pass
#:import x

# statement with as
with x as y:
  pass
#:import x

# statement with as 2
with x as y, a as b:
  pass
#:import x, a

# statement with async
async with x:
  pass
#:import x

# function
def foo():
  pass
#:export foo

# async function
async def foo():
  pass
#:export foo

# function decorate
@x
def foo():
  pass
#:import x
#:export foo

# function decorate 2
@x
@y
def foo():
  pass
#:import x, y
#:export foo

# function decorate
@x.y
def foo():
  pass
#:import x
#:export foo

# function decorate
@x.y(z)
def foo():
  pass
#:import x, z
#:export foo

# function return
def foo() -> x:
  pass
#:export foo

# function pos arg
def foo(x):
  pass
#:export foo

# function pos arg annotate
def foo(x: y):
  pass
#:export foo

# function pos arg 2
def foo(x, y):
  pass
#:export foo

# function var arg
def foo(x, *y):
  pass
#:export foo

# function var kw arg
def foo(*y, **z):
  pass
#:export foo

# function var kw arg annotate
def foo(*y: a, **z: a):
  pass
#:export foo

# function kw arg
def foo(x, y = 1):
  pass
#:export foo

# function kw arg
def foo(x, y = a):
  pass
#:import a
#:export foo

# function kw arg var
def foo(x, y = 1, *z):
  pass
#:export foo

# function kw arg kw
def foo(x, y = 1, **z):
  pass
#:export foo

# class
class foo:
  pass
#:export foo

# class decorate
@x
class foo:
  pass
#:import x
#:export foo

# class decorate 2
@x
@y
class foo:
  pass
#:import x, y
#:export foo

# class decorate
@x.y
class foo:
  pass
#:import x
#:export foo

# class decorate
@x.y(z)
class foo:
  pass
#:import x, z
#:export foo

# class base
class foo(x):
  pass
#:import x
#:export foo

# class bases
class foo(x, y):
  pass
#:import x, y
#:export foo

# labeled break contextmgr
class Label(BaseException):
  __slots__ = ()

  def __enter__(self):
    return self

  def brk(self):
    raise self

  def __exit__(self, etyp, exc, tb):
    return exc is self
#:export Label

# labeled statement
with Label() as name:
  pass
#:import Label

# boxed val
class Box:
  __slots__ = ('type', 'vector')
  def __init__(self, type, vector):
    self.type = type
    self.vector = vector
  def __getitem__(self, index):
    return getattr(self, self.__slots__[index])
  def __bool__(self):
    return self.type != 'Void'
  def __repr__(self):
    return 'Void' if self.type is 'Void' else repr(self.vector)
#:export Box

# str join
''.join(map(str, parts))
#:import parts

# method call chain
foo().bar().qux()
#:import foo
