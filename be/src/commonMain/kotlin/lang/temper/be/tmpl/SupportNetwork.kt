package lang.temper.be.tmpl

import lang.temper.be.TargetLanguageTypeName
import lang.temper.builtin.RuntimeTypeOperation
import lang.temper.interp.LongLivedUserFunction
import lang.temper.lexer.Genre
import lang.temper.log.Position
import lang.temper.name.BuiltinName
import lang.temper.name.ResolvedName
import lang.temper.type.MethodShape
import lang.temper.type.TypeShape
import lang.temper.type.WellKnownTypes
import lang.temper.type2.Signature2
import lang.temper.type2.Type2
import lang.temper.type2.hackMapOldStyleToNew
import lang.temper.value.BuiltinOperatorId
import lang.temper.value.CoverFunction
import lang.temper.value.FunTree
import lang.temper.value.MacroValue
import lang.temper.value.NamedBuiltinFun
import lang.temper.value.TInt
import lang.temper.value.Value

/**
 * Allows a backend to guide the production of a [TmpL.ModuleSet] produced from the Lispy form
 * generated by the frontend.
 * Most importantly, it allows a backend to relate pieces of runtime code, [SupportCode], to
 * generated names.
 *
 * In the layered AST, relations between names and support code are represented by
 * [TmpL.SupportCodeDeclaration]s.
 *
 * When support code for a Temper [builtin][NamedBuiltinFun] requires pieces of support code
 * not related to any Temper, this may use [PoolFiller.supportCode] to get a name previously
 * associated or create an association.
 */
interface SupportNetwork {
    val backendDescription: String

    /** Whether to use `if` or `try`/`catch` to branch to recovery paths on *Bubble* */
    val bubbleStrategy: BubbleBranchStrategy

    /** How to translate coroutines. */
    val coroutineStrategy: CoroutineStrategy

    /** How to translate types for function-like values. */
    val functionTypeStrategy: FunctionTypeStrategy

    /**
     * Whether a variable that is [assignOnce][TmpL.ModuleOrLocalDeclaration.assignOnce]
     * may be assigned in both a [TmpL.TryStatement]'s [tried][TmpL.TryStatement.tried] and
     * recover branches.
     *
     * Only relevant when [bubbleStrategy] is [BubbleBranchStrategy.CatchBubble].
     */
    val mayAssignInBothTryAndRecover: Boolean get() = true

    /**
     * Define true for languages where unlabeled break exits a [TmpL.ComputedJumpStatement]
     * rather than an outside loop. If set to true, TmpL code will be automatically changed
     * to use labeled breaks in such cases.
     */
    val needsLabeledBreakFromSwitch: Boolean get() = false

    /** The way to represent void return values in module and function bodies. */
    fun representationOfVoid(genre: Genre): RepresentationOfVoid

    /** Whether to simplify OrType members beyond Bubble or Null. */
    val simplifyOrTypes: Boolean get() = false

    fun getSupportCode(
        pos: Position,
        /** The builtin for which we need support code. */
        builtin: NamedBuiltinFun,
        genre: Genre,
    ): SupportCode?

    /**
     * Allows substituting a pre-existing function for a combination of builtins, e.g. infix `-`.
     */
    fun getSupportCode(
        pos: Position,
        /** The cover function for which we need support code. */
        coverFunction: CoverFunction,
        genre: Genre,
    ): SupportCode? {
        val covered = coverFunction.covered
        if (covered.size == 1) {
            val fn = covered[0]
            if (fn is NamedBuiltinFun) {
                return getSupportCode(pos, fn, genre)
            }
        }
        return null
    }

    fun getSupportCode(
        pos: Position,
        fn: MacroValue,
        genre: Genre,
    ): SupportCode? = when (fn) {
        is NamedBuiltinFun -> getSupportCode(pos, fn, genre)
        is CoverFunction -> getSupportCode(pos, fn, genre)
        is LongLivedUserFunction -> (fn.stayLeaf.incoming?.source as? FunTree)?.parts?.connected?.let { key ->
            translateConnectedReference(pos, key, genre)
        }
        else -> null
    }

    /**
     * Some backends need library snippets associated with a name.
     * For example, JavaScript does not have builtin support for `interface` types so having a name
     * for some library code that allows declaring something interoperates with `instanceof` is
     * convenient.
     *
     * Since it's optional, this method does not take a name.  Instead, this method allows opting
     * into having such a thing available based on whether chosen *TmpLTranslator* paths are taken.
     * A tree translator may later scan [TmpL.Module]s to find support code references to optional
     * builtins and store the associated names before translating modules.
     *
     * @return the support code that is optionally needed or null if it's not required,
     *     and a type for the declaration.
     */
    fun optionalSupportCode(
        optionalSupportCodeKind: OptionalSupportCodeKind,
    ): Pair<SupportCode, Signature2>?

    /**
     * Translate connected method references, like `String::isEmpty` to support code.
     * Return value null indicates that the original Temper method implementation should be used.
     */
    fun translateConnectedReference(
        pos: Position,
        connectedKey: String,
        genre: Genre,
    ): SupportCode?

    /**
     * Translate a connected type, like `Date` to a backend-specific representation of
     * the type, and possibly some type parameters.
     *
     * The particular subclass of [TargetLanguageTypeName] should be something the
     * internals of [the backend's translator][lang.temper.be.Backend.translate]
     * understand.
     *
     * Return value null indicates that the original Temper type should be used.
     */
    fun translatedConnectedType(
        pos: Position,
        connectedKey: String,
        genre: Genre,
        temperType: Type2,
    ): Pair<TargetLanguageTypeName, List<Type2>>?

    fun translateRuntimeTypeOperation(
        pos: Position,
        rto: RuntimeTypeOperation,
        sourceType: TmpL.NominalType,
        targetType: TmpL.NominalType,
    ): SupportCode? {
        if (sourceType.typeName.sourceDefinition == WellKnownTypes.stringIndexOptionTypeDefinition) {
            when (targetType.typeName.sourceDefinition) {
                WellKnownTypes.noStringIndexTypeDefinition -> when (rto) {
                    RuntimeTypeOperation.As, RuntimeTypeOperation.AssertAs -> {} // TODO: require < 0 and return it
                    RuntimeTypeOperation.Is -> return lessThanZero
                }
                WellKnownTypes.stringIndexTypeDefinition -> when (rto) {
                    RuntimeTypeOperation.As, RuntimeTypeOperation.AssertAs -> {} // TODO: require >= 0 and return it
                    RuntimeTypeOperation.Is -> return greaterEqualToZero
                }
                else -> {}
            }
        }
        return null
    }

    val needsLocalNameForExternallyDefinedType: Boolean get() = false
    val needsLocalNameForExternallyDefinedFunction: Boolean get() = false
    val needsLocalNameForExternallyDefinedValue: Boolean get() = false

    /**
     * Are getters and setters for computed properties translated separately?
     *
     * This determines whether, when a getter and setter have different visibility,
     * whether one might get a [TmpL.ExternalPropertyId] and the other a [TmpL.InternalPropertyId].
     *
     * For example, in C#, computed properties are not split, and the visibility can be specified
     * for each independently, so there is no need for different names for the two parts:
     *
     * ```c#
     * public PropertyType PropertyName {get; private set}
     * ```
     *
     * ```kt
     * var propertyName: PropertyType
     *   private set
     * ```
     *
     * In JavaScript, the names need to differ because that is how privateness is understood.
     *
     * ```js
     * get propertyName() { ... }
     * set #propertyName(newValue) { ... }
     * ```
     *
     * Any assignment to `#propertyName` would need to include the `#`: `this.#propertyName = ...`,
     * so the corresponding [TmpL.SetAbstractProperty] should have a [TmpL.InternalPropertyId].
     *
     * In Java, the two are distinct because Java uses getter and setter methods, so a Java backend
     * could go either way.
     *
     * ```java
     * public PropertyType getPropertyName() { ... }
     * private void setPropertyName(PropertyType newValue) { ... }
     * ```
     *
     * Defaults to false.
     */
    val splitComputedProperties: Boolean get() = false

    /**
     * If a method signature may need to change based on expectations created by an overridden
     * method, then adjust them here.
     *
     * For example, in Java, all generic types are reference types.
     * Below, a Temper class specializes a generic interface.
     * A Java translation of the interface needs to adjust the type parameter from the Java
     * value type `int` to the corresponding reference type `java.lang.Integer`.
     *
     * Doing those adjustments here allows them to be collected and shared with other libraries
     * so that calls to the method may also perform corresponding adjustments.
     */
    fun maybeAdjustMethodSignature(
        unadjustedSignature: Signature2,
        method: MethodShape,
    ): SignatureAdjustments? = null

    /**
     * Returns non-null to insert an explicit cast between different types.
     *
     * For example, consider a function declaration and a use like the below:
     *
     *     let f<T>(x: T): T { x }
     *
     *     let s: String = "Hello, World!";
     *
     *     console.log( f<String>() );
     *
     * The function `f` takes a `<T>`, but is called with an actual String, and
     * then it returns a `T` which is used as a `String`.  That leads to the
     * following sequence of calls to this affordance:
     *
     * | Context                 | From actual | From declared | To actual | To declared |
     * | ----------------------- | ----------- | ------------- | --------- | ----------- |
     * | Passing s to f          | String      | String        | String    | \<T>        |
     * | Receiving result from f | String      | \<T>          | String    | String      |
     *
     * A String, represented as a String, is passed to a function as a parameter.
     * That function receives the String, but the declared type of `x` is \<T>.
     *
     * Later, that function returns a String, declared as a \<T>, back to its caller.
     * The caller receives a String, declared as a String.
     *
     * Later, that String is passed to `console.log` but since there's no mismatch between
     * the actual and declared type in that interaction, this method is not called again.
     *
     * This is primarily for languages that require explicit boxing/unboxing
     * operations or other coercions between different representations of the
     * same notional type.
     *
     * @return null indicates no coercion is needed.
     */
    fun maybeInsertImplicitCast(
        fromActualType: Type2,
        fromDeclaredType: Type2,
        fromAdjustment: SignatureAdjustments.SignatureAdjustment?,
        toActualType: Type2,
        toDeclaredType: Type2,
        toAdjustment: SignatureAdjustments.SignatureAdjustment?,
        builtinOperatorId: BuiltinOperatorId?,
    ): SupportCode? = null

    /**
     * May be overridden by backends to add members to translated type declarations.
     *
     * Use cases include:
     *
     * - adding `toString` style methods for easy logging
     * - adding `toJSON` methods in JavaScript to allow
     *   non-generic types easy interop with the JSON.stringify builtin.
     */
    fun adjustTypeMembers(
        typeShape: TypeShape,
        members: List<TmpL.MemberOrGarbage>,
        translationAssistant: TranslationAssistant,
    ): List<TmpL.MemberOrGarbage> {
        return members
    }
}

interface PoolFiller {
    fun value(v: Value<*>): ResolvedName?
    fun builtin(f: NamedBuiltinFun): ResolvedName
    fun supportCode(c: SupportCode): ResolvedName
}

/** @see [SupportNetwork.optionalSupportCode] */
enum class OptionalSupportCodeKind {
    EnumTypeSupport,
    InterfaceTypeSupport,
}

private fun compareToZero(
    operator: TmpLOperator.Infix,
    pos: Position,
    args: List<TypedArg<TmpL.Tree>>,
    strict: Boolean,
): TmpL.Expression {
    val operand: TmpL.Expression = (args.getOrNull(0)?.expr as? TmpL.Expression)
        ?: run<TmpL.Expression> {
            require(!strict)
            TmpL.Reference(
                TmpL.Id(pos, BuiltinName("a")),
                hackMapOldStyleToNew(WellKnownTypes.intType),
            )
        }
    val rpos = pos.rightEdge
    return TmpL.InfixOperation(
        pos,
        operand,
        TmpL.InfixOperator(rpos, operator),
        TmpL.ValueReference(rpos, Value(0, TInt), 0),
    )
}

private val lessThanZero = InlineTmpLSupportCode.of { pos, args, _, _, strict ->
    compareToZero(TmpLOperator.LtInt, pos, args, strict)
}

private val greaterEqualToZero = InlineTmpLSupportCode.of { pos, args, _, _, strict ->
    compareToZero(TmpLOperator.GeInt, pos, args, strict)
}
